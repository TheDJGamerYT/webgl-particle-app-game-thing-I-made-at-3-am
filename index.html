<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Particle Text</title>
  <style>
    html,body{height:100%;margin:0;background:#0b0c10;overflow:hidden;color:#fff;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto}
    canvas{display:block;position:fixed;top:0;left:0;width:100%;height:100%;z-index:0}
    #controls{position:fixed;bottom:10px;left:50%;transform:translateX(-50%);z-index:3;display:flex;gap:10px;align-items:center}
    #textInput, #imageUpload, #formImageBtn{padding:8px 12px;border-radius:6px;border:none;font-size:16px;width:300px;background:#111;color:#fff}
    #densitySelect, #particleAmountSelect, #toggleMode{padding:6px 10px;border-radius:6px;border:none;font-size:14px;background:#111;color:#fff}
    #imageUpload, #formImageBtn{display:none;}
    #msg{position:fixed;top:18px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.65);padding:8px 12px;border-radius:8px;z-index:4;font-size:13px;display:none}
  </style>
</head>
<body>
<div id="msg" aria-live="polite"></div>
<div id="controls">
  <input id="textInput" type="text" value="HELLO ðŸŒŽâœ¨" autocomplete="off" />
  <input id="imageUpload" type="file" accept="image/*" />
  <button id="formImageBtn" disabled>Form Image</button>
  <select id="densitySelect">
    <option value="1">Low</option>
    <option value="1.5">Medium</option>
    <option value="2">Med-High</option>
    <option value="2.5">High</option>
    <option value="3">Ultra</option>
  </select>
  <select id="particleAmountSelect">
    <option value="8000">Default (8000)</option>
    <option value="12000">Medium Amount (12000)</option>
    <option value="15000">High Amount (15000, may cause lag)</option>
  </select>
  <select id="toggleMode">
    <option value="text">Text Mode</option>
    <option value="image">Image Mode</option>
  </select>
</div>
<canvas id="canvas"></canvas>
<script>
// Restored missing rasterize functions and event handlers; fixed FPS reset to continue animation
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const msgEl = document.getElementById('msg');
const textInput = document.getElementById('textInput');
const imageUpload = document.getElementById('imageUpload');
const formImageBtn = document.getElementById('formImageBtn');
const densitySelect = document.getElementById('densitySelect');
const particleAmountSelect = document.getElementById('particleAmountSelect');
const toggleMode = document.getElementById('toggleMode');

let particles = [];
let mouse = {x: null, y: null};
let rasterPoints = null;
let particleSize = 0.6;
let charsPerLine = 16;
const baseParticleCount = 8000;
let desiredParticles = baseParticleCount;
let densityMultiplier = 1;
let uploadedImage = null;
let mode = 'text';

// FPS monitoring
let fpsHistory = [];
let lastFrameTime = performance.now();

function showMessage(text, ms = 2500){
  msgEl.textContent = text;
  msgEl.style.display = 'block';
  clearTimeout(showMessage._t);
  showMessage._t = setTimeout(()=>{ msgEl.style.display = 'none'; }, ms);
}

function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
function randomColor(){ return `rgba(${randInt(90,220)},${randInt(90,220)},${randInt(90,220)},0.85)`; }

class Particle{
  constructor(x,y){
    this.x = x; this.y = y; this.ox = x; this.oy = y;
    this.vx = 0; this.vy = 0;
    this.size = particleSize;
    this.baseColor = randomColor();
    this.color = this.baseColor;
    this.target = null;
    this.isDisrupted = false;
    this.moveDuration = randInt(1,5);
    this.cooldown = 0;
    this.reassignDelay = randInt(60, 300);
  }
  update(){
    let tx = this.ox, ty = this.oy;
    if(this.target){ tx = this.target.x; ty = this.target.y; }

    if(this.cooldown <= 0 && this.reassignDelay <= 0){
      const dx = tx - this.x;
      const dy = ty - this.y;
      const ease = 0.025 / this.moveDuration;
      this.vx += dx * ease;
      this.vy += dy * ease;
    } else {
      if(this.cooldown > 0) this.cooldown--;
      if(this.reassignDelay > 0) this.reassignDelay--;
    }

    if(mouse.x !== null){
      const dxm = this.x - mouse.x;
      const dym = this.y - mouse.y;
      const d2 = dxm*dxm + dym*dym;
      const R = 100;
      if(d2 < R*R){
        const d = Math.sqrt(d2) + 0.0001;
        const f = (1 - (d / R)) * 4.0;
        this.vx += (dxm/d) * f;
        this.vy += (dym/d) * f;
        this.color = `rgba(${randInt(0,255)},${randInt(0,255)},${randInt(0,255)},0.95)`;
        this.isDisrupted = true;
        this.cooldown = randInt(60, 300);
      }
    }

    this.vx += (Math.random()-0.5) * 0.01;
    this.vy += (Math.random()-0.5) * 0.01;
    this.vx *= 0.9; this.vy *= 0.9;
    this.x += this.vx; this.y += this.vy;

    if(!this.target){ this.color = this.baseColor; }
    else if(this.target.color && !this.isDisrupted && this.cooldown <= 0 && this.reassignDelay <= 0){
      this.color = this.target.color;
    }
    if(this.isDisrupted){ this.color = this.target && this.target.color ? this.target.color : this.baseColor; this.isDisrupted = false; }

    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
    ctx.fillStyle = this.color;
    ctx.fill();
  }
}

function initParticles(count = desiredParticles){
  desiredParticles = Math.max(0, Math.floor(count));
  particles = [];
  const cols = Math.max(1, Math.floor(Math.sqrt(desiredParticles * (canvas.width/canvas.height))));
  const rows = Math.max(1, Math.floor(desiredParticles / cols));
  const xStep = canvas.width / cols;
  const yStep = canvas.height / rows;
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      const x = c * xStep + xStep/2;
      const y = r * yStep + yStep/2;
      particles.push(new Particle(x,y));
      if(particles.length >= desiredParticles) return;
    }
  }
}

function rasterizeText(text){
  const offCanvas = document.createElement('canvas');
  offCanvas.width = canvas.width; offCanvas.height = canvas.height;
  const offCtx = offCanvas.getContext('2d');
  offCtx.fillStyle = '#000'; offCtx.fillRect(0,0,offCanvas.width,offCanvas.height);

  const estimatedCharRatio = 0.6;
  let fontSize = Math.floor(canvas.width / (charsPerLine * estimatedCharRatio));
  fontSize = Math.max(20, Math.min(fontSize, Math.floor(canvas.height/2)));

  offCtx.fillStyle = '#fff';
  offCtx.font = `bold ${fontSize}px sans-serif`;
  offCtx.textBaseline = 'top'; offCtx.textAlign = 'left';

  const lines = [];
  for(let i=0;i<text.length;i+=charsPerLine){ lines.push(text.slice(i,i+charsPerLine)); }
  const startX = 20; const startY = 20;
  lines.forEach((ln, idx)=> offCtx.fillText(ln, startX, startY + idx * Math.floor(fontSize * 1.05)));

  rasterPoints = extractPoints(offCtx, offCanvas);
  return rasterPoints;
}

function rasterizeImage(img){
  const offCanvas = document.createElement('canvas');
  offCanvas.width = canvas.width; offCanvas.height = canvas.height;
  const offCtx = offCanvas.getContext('2d');
  const ratio = Math.min(offCanvas.width / img.width, offCanvas.height / img.height);
  const iw = Math.max(1, Math.floor(img.width * ratio));
  const ih = Math.max(1, Math.floor(img.height * ratio));
  const ix = Math.floor((offCanvas.width - iw) / 2);
  const iy = Math.floor((offCanvas.height - ih) / 2);
  offCtx.fillStyle = '#000'; offCtx.fillRect(0,0,offCanvas.width,offCanvas.height);
  offCtx.drawImage(img, ix, iy, iw, ih);
  rasterPoints = extractPoints(offCtx, offCanvas);
  if(!rasterPoints || rasterPoints.length === 0){ showMessage('No visible pixels found in image â€” try a different image or increase particle count'); }
  return rasterPoints;
}

function extractPoints(offCtx, offCanvas){
  const imgData = offCtx.getImageData(0,0,offCanvas.width,offCanvas.height).data;
  const points = [];
  const baseStep = Math.sqrt((canvas.width*canvas.height)/(desiredParticles*1.5));
  const step = Math.max(1, Math.floor(baseStep / densityMultiplier));
  for(let y = 0; y < offCanvas.height; y += step){
    for(let x = 0; x < offCanvas.width; x += step){
      const idx = (Math.floor(y) * offCanvas.width + Math.floor(x)) * 4;
      const r = imgData[idx], g = imgData[idx+1], b = imgData[idx+2];
      if(r+g+b > 60){ points.push({x,y,color:`rgba(${r},${g},${b},0.95)`}); }
    }
  }
  return points;
}

function assignRasterTargets(initial){
  if(!rasterPoints) return;
  if(rasterPoints.length > particles.length){ initParticles(rasterPoints.length); }

  for(let i=0;i<particles.length;i++){
    if(i < rasterPoints.length){
      particles[i].target = rasterPoints[i];
      if(rasterPoints[i].color) particles[i].color = rasterPoints[i].color;
      particles[i].reassignDelay = initial ? 0 : randInt(60, 300);
    } else { particles[i].target = null; }
  }
}

function resize(){
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  initParticles(desiredParticles);
  if(mode === 'text'){
    rasterizeText(textInput.value || '');
    assignRasterTargets(true);
  } else if(mode === 'image' && uploadedImage){
    try{ rasterizeImage(uploadedImage); assignRasterTargets(true); }
    catch(err){ console.error('resize rasterizeImage error', err); }
  }
}
window.addEventListener('resize', debounce(resize, 120));

// --- UI wiring ---
textInput.addEventListener('input', e => {
  if(mode === 'text'){
    rasterizeText(e.target.value || '');
    assignRasterTargets(false);
  }
});

densitySelect.addEventListener('change', e => {
  densityMultiplier = parseFloat(e.target.value) || 1;
  if(mode === 'text'){
    rasterizeText(textInput.value || '');
    assignRasterTargets(false);
  } else if(mode === 'image' && uploadedImage){
    rasterizeImage(uploadedImage);
    assignRasterTargets(false);
  }
});

particleAmountSelect.addEventListener('change', e => {
  desiredParticles = parseInt(e.target.value) || baseParticleCount;
  initParticles(desiredParticles);
  if(mode === 'text'){
    rasterizeText(textInput.value || '');
    assignRasterTargets(true);
  } else if(mode === 'image' && uploadedImage){
    rasterizeImage(uploadedImage);
    assignRasterTargets(true);
  }
});

toggleMode.addEventListener('change', e => {
  mode = e.target.value;
  if(mode === 'image'){
    textInput.style.display = 'none';
    imageUpload.style.display = 'inline-block';
    formImageBtn.style.display = 'inline-block';
    formImageBtn.disabled = !uploadedImage;
  } else {
    textInput.style.display = 'inline-block';
    imageUpload.style.display = 'none';
    formImageBtn.style.display = 'none';
    formImageBtn.disabled = true;
    if(mode === 'text'){
      if(textInput.value) rasterizeText(textInput.value);
      else rasterPoints = null;
      assignRasterTargets(true);
    }
  }
});

function isImageFile(file){
  if(!file) return false;
  if(file.type && file.type.startsWith('image/')) return true;
  const name = (file.name || '').toLowerCase();
  return /\.(png|jpe?g|gif|webp|bmp|svg)$/i.test(name);
}

imageUpload.addEventListener('change', e => {
  const file = e.target.files && e.target.files[0];
  if(!file){ uploadedImage = null; formImageBtn.disabled = true; showMessage('No file selected'); return; }
  if(!isImageFile(file)){
    uploadedImage = null; formImageBtn.disabled = true; showMessage('Selected file is not a supported image type'); return;
  }

  formImageBtn.disabled = true;
  showMessage('Loading image...');

  const reader = new FileReader();
  reader.onload = () => {
    const dataURL = reader.result;
    const img = new Image();
    img.onload = () => {
      uploadedImage = img;
      formImageBtn.disabled = false;
      showMessage('Image ready â€” press "Form Image"');
    };
    img.onerror = () => {
      uploadedImage = null; formImageBtn.disabled = true; showMessage('Failed to load image (file may be corrupted or unsupported)');
    };
    img.src = dataURL;
  };
  reader.onerror = () => { uploadedImage = null; formImageBtn.disabled = true; showMessage('Error reading file'); };
  try{ reader.readAsDataURL(file); } catch(err){ uploadedImage = null; formImageBtn.disabled = true; showMessage('Error reading file'); }
});

formImageBtn.addEventListener('click', async () => {
  if(!uploadedImage){
    const file = imageUpload.files && imageUpload.files[0];
    if(!file){ showMessage('No image to form'); return; }
    if(!isImageFile(file)){ showMessage('Not a supported image'); return; }
    formImageBtn.disabled = true;
    const reader = new FileReader();
    reader.onload = () => {
      const img = new Image();
      img.onload = () => {
        uploadedImage = img;
        formImageBtn.disabled = false;
        try{ rasterizeImage(uploadedImage); assignRasterTargets(true); textInput.value = ''; showMessage('Image formed'); }
        catch(err){ console.error(err); showMessage('Failed to form image'); }
      };
      img.onerror = () => { formImageBtn.disabled = false; showMessage('Failed to load image'); };
      img.src = reader.result;
    };
    reader.onerror = () => { formImageBtn.disabled = false; showMessage('Failed to read file'); };
    try{ reader.readAsDataURL(file); } catch(err){ formImageBtn.disabled = false; showMessage('Failed to read file'); }
    return;
  }

  try{
    rasterizeImage(uploadedImage);
    assignRasterTargets(true);
    textInput.value = '';
    showMessage('Image formed');
  } catch(err){
    console.error('rasterizeImage error', err);
    showMessage('Failed to form image (see console)');
  }
});

function animate(){
  const now = performance.now();
  const delta = now - lastFrameTime;
  lastFrameTime = now;
  const fps = 1000 / delta;
  fpsHistory.push(fps);
  if(fpsHistory.length > 60) fpsHistory.shift();
  const avgFps = fpsHistory.reduce((a,b)=>a+b,0)/fpsHistory.length;

  if(avgFps < 5){
    console.warn("Low FPS detected, resetting canvas to save memory");
    // reset to a safe state but keep animating
    desiredParticles = baseParticleCount;
    initParticles(desiredParticles);
    rasterPoints = null;
    showMessage('Low FPS â€” canvas reset to save memory');
    fpsHistory = [];
  }

  ctx.fillStyle = 'rgba(11,12,16,0.35)';
  ctx.fillRect(0,0,canvas.width,canvas.height);
  for(const p of particles) p.update();
  requestAnimationFrame(animate);
}

canvas.addEventListener('mousemove', e=>{ mouse.x = e.clientX; mouse.y = e.clientY; });
canvas.addEventListener('mouseleave', ()=>{ mouse.x = null; mouse.y = null; });

// start
initParticles();
if(textInput.value) rasterizeText(textInput.value);
assignRasterTargets(true);
animate();

function debounce(fn, t){ let id = null; return (...a)=>{ clearTimeout(id); id = setTimeout(()=>fn(...a), t); }; }
</script>
</body>
</html>
